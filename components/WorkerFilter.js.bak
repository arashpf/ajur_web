import React, { useState, useEffect } from "react";
import axios from "axios";
import { useRouter } from "next/router";
import {
  Box,
  Button,
  Grid,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Slider,
  CircularProgress,
  Divider,
  Typography,
  Chip,
  Stack,
  Menu,
  MenuItem,
  useMediaQuery,
  Skeleton,
  useTheme,
  TextField,
  Paper,
} from "@mui/material";
import {
  ExpandMore,
  Delete,
  CheckBoxOutlineBlank,
  CheckBox,
  RadioButtonChecked,
  RadioButtonUnchecked,
  Close,
  Tune,
  ArrowBack,
  Sort,
} from "@mui/icons-material";

// Utility functions
const convertToPersianDigits = (str) => {
  if (!str) return "";
  return str.toString().replace(/\d/g, (d) => "۰۱۲۳۴۵۶۷۸۹"[d]);
};

const formatNumber = (num) => {
  if (num === "" || num === null || num === undefined) return "";
  const number = parseFloat(num);
  if (isNaN(number)) return "";

  return convertToPersianDigits(
    number.toLocaleString("en-US", { maximumFractionDigits: 0 })
  );
};

const formatNumberWithWords = (num) => {
  if (num === "" || num === null || num === undefined) return "";
  const number = parseFloat(num);
  if (isNaN(number)) return "";

  // For numbers >= 1 billion
  if (number >= 1000000000) {
    const billions = Math.floor(number / 1000000000);
    const remainder = number % 1000000000;
    let result = `${convertToPersianDigits(billions.toString())} میلیارد`;
    if (remainder > 0) {
      const millions = Math.floor(remainder / 1000000);
      result += ` و ${convertToPersianDigits(millions.toString())} میلیون`;
    }
    return result;
  }

  // For numbers >= 1 million
  if (number >= 1000000) {
    const millions = Math.floor(number / 1000000);
    const remainder = number % 1000000;
    let result = `${convertToPersianDigits(millions.toString())} میلیون`;
    if (remainder > 0) {
      const thousands = Math.floor(remainder / 1000);
      result += ` و ${convertToPersianDigits(thousands.toString())} هزار`;
    }
    return result;
  }

  // For numbers >= 1000
  if (number >= 1000) {
    const thousands = Math.floor(number / 1000);
    const remainder = number % 1000;
    let result = `${convertToPersianDigits(thousands.toString())} هزار`;
    if (remainder > 0) {
      result += ` و ${convertToPersianDigits(remainder.toString())}`;
    }
    return result;
  }

  return convertToPersianDigits(number.toString());
};

const WorkerFilter = ({
  workers = [],
  onFilteredWorkersChange,
  onLoadingChange = null,
  initialCategory = null,
  onCategoryChange = null,
}) => {
  const router = useRouter();

  // Do not render this filter inside the admin/ panel area
  if (router && typeof router.pathname === "string" && router.pathname.startsWith("/panel")) {
    return null;
  }

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));

  // State
  const [isFilterOpen, setIsFilterOpen] = useState(!isMobile);
  const [selectedCategory, setSelectedCategory] = useState(initialCategory);
  const [selectedNeighborhoods, setSelectedNeighborhoods] = useState([]);
  const [selectedFeatures, setSelectedFeatures] = useState([]);
  const [rangeFilters, setRangeFilters] = useState([]);
  const [filterLevel, setFilterLevel] = useState("base");
  const [sortAnchorEl, setSortAnchorEl] = useState(null);
  const [sortBy, setSortBy] = useState("newest");
  const [loading, setLoading] = useState(true);
  const [focusedField, setFocusedField] = useState(null); // Track which field is focused
  const [filterTimeout, setFilterTimeout] = useState(null); // Timeout for debouncing
  const [moreFiltersExpanded, setMoreFiltersExpanded] = useState(true); // State for collapsible filters - open by default
  const [featuresExpanded, setFeaturesExpanded] = useState(false); // State for features dropdown

  // Data
  const [categories, setCategories] = useState([]);
  const [neighborhoods, setNeighborhoods] = useState([]);

  // State for dynamically extracted filters
  const [dynamicRangeFilters, setDynamicRangeFilters] = useState([]);
  const [dynamicFeatures, setDynamicFeatures] = useState([]);

  // Get suggested values based on field name and type
  const getSuggestionsByFieldName = (fieldName) => {
    const lowerField = fieldName.toLowerCase();

    // Price suggestions for price-related fields
    if (lowerField.includes("قیمت")) {
      return [
        { value: 500000000, label: "۵۰۰ میلیون" },
        { value: 1000000000, label: "۱ میلیارد" },
        { value: 1500000000, label: "۱/۵ میلیارد" },
        { value: 2000000000, label: "۲ میلیارد" },
        { value: 2500000000, label: "۲/۵ میلیارد" },
        { value: 3000000000, label: "۳ میلیارد" },
        { value: 5000000000, label: "۵ میلیارد" },
        { value: 10000000000, label: "۱۰ میلیارد" },
      ];
    }

    // Area suggestions for area-related fields
    if (lowerField.includes("متراژ")) {
      return [
        { value: 50, label: "۵۰ متر" },
        { value: 70, label: "۷۰ متر" },
        { value: 100, label: "۱۰۰ متر" },
        { value: 120, label: "۱۲۰ متر" },
        { value: 150, label: "۱۵۰ متر" },
        { value: 200, label: "۲۰۰ متر" },
        { value: 250, label: "۲۵۰ متر" },
        { value: 300, label: "۳۰۰ متر" },
      ];
    }

    return [];
  };

  // Extract filters from actual category data
  const extractCategoryFilters = (categoryId) => {
    if (!categoryId || !workers || workers.length === 0) {
      setDynamicRangeFilters([]);
      setDynamicFeatures([]);
      return;
    }

    // Get all workers for this category
    const categoryWorkers = workers.filter(
      (w) => parseInt(w.category_id) === categoryId
    );

    if (categoryWorkers.length === 0) {
      setDynamicRangeFilters([]);
      setDynamicFeatures([]);
      return;
    }

    // Extract all unique properties from json_properties
    const allProperties = new Map();
    const booleanProperties = new Map();

    categoryWorkers.forEach((worker) => {
      try {
        const props = JSON.parse(worker.json_properties || "[]");
        props.forEach((prop) => {
          // kind: 1 = numeric, 2 = boolean, 3 = select
          if (prop.kind === 1 && !allProperties.has(prop.name)) {
            allProperties.set(prop.name, {
              name: prop.name,
              value: prop.name,
              unit: prop.name === "متراژ" ? "متر" : "تومان",
              kind: 1,
              order: prop.order,
              min: 0,
              max: 10000, // Default, will be calculated
            });
          }
          if (prop.kind === 2 && !booleanProperties.has(prop.name)) {
            booleanProperties.set(prop.name, {
              id: Math.random(),
              name: prop.name,
              value: prop.name,
            });
          }
        });
      } catch (e) {
        console.error("Error parsing json_properties:", e);
      }
    });

    // Calculate proper min/max for numeric fields
    const rangeFilters = Array.from(allProperties.values())
      .sort((a, b) => (a.order || 0) - (b.order || 0))
      .map((field, idx) => ({
        ...field,
        id: idx + 1,
      }));

    const features = Array.from(booleanProperties.values());

    setDynamicRangeFilters(rangeFilters);
    setDynamicFeatures(features);
  };

  // Extract filters when category or workers change
  useEffect(() => {
    if (selectedCategory) {
      extractCategoryFilters(selectedCategory.id);
    }
  }, [selectedCategory, workers]);

  // Convert number to Persian words
  const numberToPersianWords = (num) => {
    if (num === "" || num === null || num === undefined) return "";

    const number = parseFloat(num);
    if (isNaN(number)) return "";

    // For small numbers (under 1000), just return the number
    if (number < 1000) {
      return convertToPersianDigits(number.toString());
    }

    // For thousands
    if (number < 1000000) {
      const thousands = Math.floor(number / 1000);
      const remainder = number % 1000;
      let result = `${convertToPersianDigits(thousands.toString())} هزار`;
      if (remainder > 0) {
        result += ` و ${convertToPersianDigits(remainder.toString())}`;
      }
      return result;
    }

    // For millions
    if (number < 1000000000) {
      const millions = Math.floor(number / 1000000);
      const remainder = number % 1000000;
      let result = `${convertToPersianDigits(millions.toString())} میلیون`;
      if (remainder > 0) {
        result += ` و ${numberToPersianWords(remainder)}`;
      }
      return result;
    }

    // For billions
    const billions = Math.floor(number / 1000000000);
    const remainder = number % 1000000000;
    let result = `${convertToPersianDigits(billions.toString())} میلیارد`;
    if (remainder > 0) {
      result += ` و ${numberToPersianWords(remainder)}`;
    }
    return result;
  };

  // Get suggestions based on filter field name
  const getSuggestions = (fieldId) => {
    const filter = dynamicRangeFilters.find(f => f.id === fieldId);
    if (!filter) return [];
    return getSuggestionsByFieldName(filter.name);
  };

  // Handle suggestion click
  const handleSuggestionClick = (fieldId, type, value) => {
    setRangeFilters((prev) =>
      prev.map((f) =>
        f.id === fieldId
          ? {
            ...f,
            [type]: value.toString(),
          }
          : f
      )
    );
    setFocusedField(null); // Close suggestions
  };

  // Initialize range filters from dynamic filters
  useEffect(() => {
    const initialRangeFilters = dynamicRangeFilters.map((field) => ({
      ...field,
      low: "", // Empty means no lower limit
      high: "", // Empty means no upper limit
    }));
    setRangeFilters(initialRangeFilters);
  }, [dynamicRangeFilters]);

  // Sync selectedCategory with initialCategory prop when it changes
  useEffect(() => {
    setSelectedCategory(initialCategory);
  }, [initialCategory]);

  // Fetch categories and neighborhoods
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get("https://api.ajur.app/api/base");
        setCategories(response.data.cats);
        setNeighborhoods(response.data.the_neighborhoods);
      } catch (error) {
        console.error("Error loading filters:", error);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  // Debounced filter application
  const applyFiltersWithDebounce = () => {
    // Notify that loading has started
    if (onLoadingChange) {
      onLoadingChange(true);
    }

    // Clear existing timeout
    if (filterTimeout) {
      clearTimeout(filterTimeout);
    }

    // Set new timeout
    const timeout = setTimeout(() => {
      const filtered = applyFilters();
      const sorted = sortWorkers(filtered);
      onFilteredWorkersChange(sorted);

      // Notify that loading is complete
      if (onLoadingChange) {
        onLoadingChange(false);
      }
    }, 300); // 300ms delay

    setFilterTimeout(timeout);
  };

  // Apply filters when dependencies change with debounce
  useEffect(() => {
    applyFiltersWithDebounce();

    // Cleanup timeout on unmount
    return () => {
      if (filterTimeout) {
        clearTimeout(filterTimeout);
      }
    };
  }, [
    workers,
    selectedCategory,
    selectedNeighborhoods,
    selectedFeatures,
    rangeFilters,
    sortBy,
  ]);

  const handleCategoryChange = () => {
    setIsFilterOpen(true);
    setFilterLevel("category");
  };

  const applyFilters = () => {
    return workers.filter((worker) => {
      // Category filter
      if (
        selectedCategory &&
        parseInt(worker.category_id) !== selectedCategory.id
      ) {
        return false;
      }

      // Neighborhood filter
      if (selectedNeighborhoods.length > 0) {
        const workerNeighborhoodId = parseInt(worker.neighborhood_id);
        if (
          !selectedNeighborhoods.some((nb) => nb.id === workerNeighborhoodId)
        ) {
          return false;
        }
      }

      // Features filter
      if (selectedFeatures.length > 0) {
        try {
          const workerProperties = JSON.parse(worker.json_properties || "[]");
          const hasAllFeatures = selectedFeatures.every((feature) =>
            workerProperties.some(
              (prop) => prop.name === feature.value && prop.kind === 2
            )
          );
          if (!hasAllFeatures) {
            return false;
          }
        } catch (e) {
          return false;
        }
      }

      // Range filters
      if (!passesRangeFilters(worker)) {
        return false;
      }

      return true;
    });
  };

  const passesRangeFilters = (worker) => {
    try {
      const workerProperties = JSON.parse(worker.json_properties || "[]");

      // If no range filters are set (all are empty), return true
      const hasActiveRangeFilters = rangeFilters.some(
        (filter) => filter.low !== "" || filter.high !== ""
      );

      if (!hasActiveRangeFilters) {
        return true;
      }

      return rangeFilters.every((filter) => {
        // If both low and high are empty, this filter is inactive
        if (filter.low === "" && filter.high === "") {
          return true;
        }

        // Try to find the property by name - look in both special and regular properties
        const workerProp = workerProperties.find(
          (prop) =>
            prop.name === filter.value || prop.name.includes(filter.value)
        );

        // If property doesn't exist and we have active filters, exclude
        if (!workerProp) {
          return false;
        }

        // Parse the worker value - handle different formats
        let workerValue;
        try {
          workerValue = parseFloat(workerProp.value);
          if (isNaN(workerValue)) {
            // Try to extract numbers from string if it contains text
            const numMatch = workerProp.value.match(/\d+/);
            workerValue = numMatch ? parseFloat(numMatch[0]) : NaN;
          }
        } catch (e) {
          return false;
        }

        if (isNaN(workerValue)) {
          return false;
        }

        // Check lower bound (if set)
        const lowerBoundOK =
          filter.low === "" || workerValue >= parseFloat(filter.low);

        // Check upper bound (if set)
        const upperBoundOK =
          filter.high === "" || workerValue <= parseFloat(filter.high);

        return lowerBoundOK && upperBoundOK;
      });
    } catch (e) {
      return false;
    }
  };

  const sortWorkers = (workersToSort) => {
    if (!workersToSort.length) return workersToSort;

    const workersCopy = [...workersToSort];

    switch (sortBy) {
      case "newest":
        return workersCopy.sort(
          (a, b) => new Date(b.updated_at || 0) - new Date(a.updated_at || 0)
        );
      case "oldest":
        return workersCopy.sort(
          (a, b) => new Date(a.updated_at || 0) - new Date(b.updated_at || 0)
        );
      case "most_viewed":
        return workersCopy.sort(
          (a, b) =>
            (parseInt(b.total_view) || 0) - (parseInt(a.total_view) || 0)
        );
      default:
        return workersCopy;
    }
  };

  // Event handlers with immediate UI feedback but debounced filtering
  const handleCategorySelect = (category) => {
    if (onCategoryChange) {
      onCategoryChange(category);
    } else {
      setSelectedCategory(category);
    }
    setFilterLevel("base");
    // Filtering will happen automatically via useEffect
  };

  const handleNeighborhoodToggle = (neighborhood) => {
    setSelectedNeighborhoods((prev) =>
      prev.some((n) => n.id === neighborhood.id)
        ? prev.filter((n) => n.id !== neighborhood.id)
        : [...prev, neighborhood]
    );
    // Filtering will happen automatically via useEffect
  };

  const handleFeatureToggle = (feature) => {
    setSelectedFeatures((prev) =>
      prev.some((f) => f.value === feature.value)
        ? prev.filter((f) => f.value !== feature.value)
        : [...prev, feature]
    );
    // Filtering will happen automatically via useEffect
  };

  const handleRangeFilterChange = (fieldId, type, value) => {
    setRangeFilters((prev) =>
      prev.map((f) =>
        f.id === fieldId
          ? {
            ...f,
            [type]: value,
          }
          : f
      )
    );
    // Filtering will happen automatically via useEffect
  };

  const handleSortChange = (newSortBy) => {
    setSortBy(newSortBy);
    setSortAnchorEl(null);
    // Filtering will happen automatically via useEffect
  };

  const handleResetAll = () => {
    // Don't clear selected category - only clear other filters
    setSelectedNeighborhoods([]);
    setSelectedFeatures([]);
    // Reset all range filters
    setRangeFilters(
      dynamicRangeFilters.map((field) => ({
        ...field,
        low: "",
        high: "",
      }))
    );
    setSortBy("newest");
    // Filtering will happen automatically via useEffect
  };

  const getSortDisplayText = () => {
    const sortTexts = {
      newest: "جدیدترین",
      oldest: "قدیمی ترین",
      most_viewed: "پر بازدید ترین",
    };
    return sortTexts[sortBy] || "مرتب‌سازی";
  };

  // Render methods
  const renderSelectedFilters = () => {
    const hasActiveFilters =
      selectedCategory ||
      selectedNeighborhoods.length > 0 ||
      selectedFeatures.length > 0 ||
      rangeFilters.some((filter) => filter.low !== "" || filter.high !== "") ||
      sortBy !== "newest";

    if (!hasActiveFilters) return null;

    return (
      <Box
        sx={{
          p: 2,
          border: "1px solid",
          borderColor: "grey.300",
          borderRadius: 2,
        }}
      >
        <Stack direction="row" spacing={1} flexWrap="wrap" useFlexGap>
          {selectedCategory && (
            <Chip
              label={`دسته‌بندی: ${selectedCategory.name}`}
              onClick={() => handleCategoryChange()}
              color="primary"
              variant="outlined"
              size="small"
            />
          )}

          {selectedNeighborhoods.map((neighborhood) => (
            <Chip
              key={neighborhood.id}
              label={`محله: ${neighborhood.name}`}
              onDelete={() =>
                setSelectedNeighborhoods((prev) =>
                  prev.filter((n) => n.id !== neighborhood.id)
                )
              }
              color="secondary"
              variant="outlined"
              size="small"
            />
          ))}

          {selectedFeatures.map((feature) => (
            <Chip
              key={feature.value}
              label={`دارای ${feature.value}`}
              onDelete={() =>
                setSelectedFeatures((prev) =>
                  prev.filter((f) => f.value !== feature.value)
                )
              }
              color="success"
              variant="outlined"
              size="small"
            />
          ))}

          {rangeFilters
            .map((filter) => {
              if (filter.low !== "" || filter.high !== "") {
                let label = `${filter.name}: `;

                if (filter.low !== "" && filter.high !== "") {
                  // Both low and high set
                  label += `${formatNumberWithWords(filter.low)} تا ${formatNumberWithWords(filter.high)} ${filter.unit}`;
                } else if (filter.low !== "") {
                  // Only low set
                  label += `از ${formatNumberWithWords(filter.low)}`;
                } else if (filter.high !== "") {
                  // Only high set
                  label += `تا ${formatNumberWithWords(filter.high)}`;
                }

                return (
                  <Chip
                    key={filter.id}
                    label={label}
                    onDelete={() => {
                      setRangeFilters((prev) =>
                        prev.map((f) =>
                          f.id === filter.id ? { ...f, low: "", high: "" } : f
                        )
                      );
                    }}
                    color="warning"
                    variant="outlined"
                    size="small"
                  />
                );
              }
              return null;
            })
            .filter(Boolean)}

          {sortBy !== "newest" && (
            <Chip
              label={`مرتب‌سازی: ${getSortDisplayText()}`}
              onDelete={() => setSortBy("newest")}
              color="info"
              variant="outlined"
              size="small"
            />
          )}

          <Chip
            label="پاک کردن همه"
            onClick={handleResetAll}
            color="error"
            variant="outlined"
            size="small"
            icon={<Delete />}
          />
        </Stack>
      </Box>
    );
  };

  const renderFeatures = () => {
    if (dynamicFeatures.length === 0) {
      return null;
    }

    return (
      <Box sx={{ mb: 2 }}>
        <Accordion
          expanded={featuresExpanded}
          onChange={() => setFeaturesExpanded(!featuresExpanded)}
          sx={{
            "&:before": {
              display: "none",
            },
            boxShadow: "0 2px 8px rgba(211, 47, 47, 0.1)",
            border: "2px solid",
            borderColor: featuresExpanded ? "#d32f2f" : "#e0e0e0",
            borderRadius: 3,
            background: "linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(240, 240, 240, 0.9) 100%)",
            transition: "all 0.3s ease",
          }}
        >
          <AccordionSummary
            expandIcon={<ExpandMore sx={{ color: featuresExpanded ? "#d32f2f" : "#666" }} />}
            sx={{
              backgroundColor: featuresExpanded ? "rgba(211, 47, 47, 0.05)" : "transparent",
              borderBottom: featuresExpanded ? "1px solid #e0e0e0" : "none",
              borderRadius: featuresExpanded ? "12px 12px 0 0" : "12px",
              minHeight: "48px",
              "& .MuiAccordionSummary-content": {
                margin: "12px 0",
              },
              "&:hover": {
                backgroundColor: "rgba(211, 47, 47, 0.02)",
              },
            }}
          >
            <Typography variant="subtitle2" sx={{ color: "#d32f2f", fontWeight: 600 }}>
              امکانات
            </Typography>
          </AccordionSummary>
          <AccordionDetails sx={{ pt: 2 }}>
            <Grid container spacing={1}>
              {dynamicFeatures.map((feature) => {
                const isSelected = selectedFeatures.some(
                  (f) => f.value === feature.value
                );

                return (
                  <Grid item xs={12} sm={6} key={feature.id}>
                    <Box
                      sx={{
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "space-between",
                        p: 2,
                        border: "2px solid",
                        borderColor: isSelected ? "#d32f2f" : "#e0e0e0",
                        borderRadius: 3,
                        background: isSelected
                          ? "linear-gradient(135deg, rgba(211, 47, 47, 0.1) 0%, rgba(192, 192, 192, 0.1) 100%)"
                          : "linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(240, 240, 240, 0.8) 100%)",
                        cursor: "pointer",
                        transition: "all 0.3s ease",
                        "&:hover": {
                          borderColor: "#d32f2f",
                          boxShadow: "0 2px 8px rgba(211, 47, 47, 0.15)",
                        },
                      }}
                      onClick={() => handleFeatureToggle(feature)}
                    >
                      <Box
                        sx={{
                          width: 24,
                          height: 24,
                          border: "2px solid",
                          borderColor: isSelected ? "#d32f2f" : "#999",
                          borderRadius: "6px",
                          background: isSelected
                            ? "linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%)"
                            : "transparent",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          transition: "all 0.2s ease",
                          flexShrink: 0,
                        }}
                      >
                        {isSelected && (
                          <CheckBox sx={{ color: "white", fontSize: 18 }} />
                        )}
                      </Box>
                      <Typography
                        variant="body2"
                        fontWeight={isSelected ? 600 : 500}
                        sx={{ color: isSelected ? "#d32f2f" : "#333", ml: 1.5 }}
                      >
                        {feature.value}
                      </Typography>
                    </Box>
                  </Grid>
                );
              })}
            </Grid>
          </AccordionDetails>
        </Accordion>
      </Box>
    );
  };

  const renderRangeFilters = () => (
    <Box sx={{ mb: 2 }}>
      <Accordion
        expanded={moreFiltersExpanded}
        onChange={() => setMoreFiltersExpanded(!moreFiltersExpanded)}
        sx={{
          "&:before": {
            display: "none",
          },
          boxShadow: "0 2px 8px rgba(211, 47, 47, 0.1)",
          border: "2px solid",
          borderColor: moreFiltersExpanded ? "#d32f2f" : "#e0e0e0",
          borderRadius: 3,
          background: "linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(240, 240, 240, 0.9) 100%)",
          transition: "all 0.3s ease",
        }}
      >
        <AccordionSummary
          expandIcon={<ExpandMore sx={{ color: moreFiltersExpanded ? "#d32f2f" : "#666" }} />}
          sx={{
            backgroundColor: moreFiltersExpanded ? "rgba(211, 47, 47, 0.05)" : "transparent",
            borderBottom: moreFiltersExpanded ? "1px solid #e0e0e0" : "none",
            borderRadius: moreFiltersExpanded ? "12px 12px 0 0" : "12px",
            minHeight: "48px",
            "& .MuiAccordionSummary-content": {
              margin: "12px 0",
            },
            "&:hover": {
              backgroundColor: "rgba(211, 47, 47, 0.02)",
            },
          }}
        >
          <Typography variant="subtitle2" sx={{ color: "#d32f2f", fontWeight: 600 }}>
            فیلترهای بیشتر
          </Typography>
        </AccordionSummary>
        <AccordionDetails sx={{ pt: 2 }}>
          <Grid container spacing={2}>
            {dynamicRangeFilters.map((filter) => {
              // Find the corresponding rangeFilter with actual values
              const rangeFilter = rangeFilters.find(rf => rf.id === filter.id);
              if (!rangeFilter) return null;

              return (
                <Grid item xs={12} key={filter.id}>
                  <Typography variant="body2" sx={{ mb: 1, fontWeight: 500 }}>
                    {filter.name} ({filter.unit})
                </Typography>

                  {/* Range inputs */}
                  <Box
                    sx={{
                      display: "flex",
                      gap: 1,
                      alignItems: "center",
                      position: "relative",
                    }}
                  >
                    {/* تا (To) - upper limit */}
                    <Box sx={{ flex: 1, position: "relative" }}>
                      <TextField
                        size="small"
                        placeholder="تا"
                        value={rangeFilter.high}
                        onChange={(e) =>
                          handleRangeFilterChange(
                            filter.id,
                            "high",
                            e.target.value
                          )
                        }
                        onFocus={() => setFocusedField(`${filter.id}-high`)}
                        onBlur={(e) => {
                          // Use setTimeout to allow click event to process first
                          setTimeout(() => {
                            // Check if the related target (what was clicked) is inside our suggestions
                            const relatedTarget = e.relatedTarget;
                            const isClickingSuggestion =
                              relatedTarget &&
                              relatedTarget.closest &&
                              relatedTarget.closest("[data-suggestion]");

                            if (!isClickingSuggestion) {
                              setFocusedField(null);
                            }
                          }, 150);
                        }}
                        fullWidth
                        type="number"
                        inputProps={{
                          min: filter.min,
                          max: filter.max,
                          style: { textAlign: "center" },
                          autoComplete: "off",
                          autoCorrect: "off",
                          autoCapitalize: "off",
                          spellCheck: "false",
                        }}
                        autoComplete="off"
                        name={`filter-${filter.id}-high`}
                        sx={{
                          "& .MuiOutlinedInput-root": {
                            borderRadius: 2.5,
                            backgroundColor: "rgba(255, 255, 255, 0.8)",
                            border: "1.5px solid #e0e0e0",
                            "&:hover": {
                              borderColor: "#d32f2f",
                              backgroundColor: "rgba(255, 255, 255, 1)",
                            },
                            "&.Mui-focused": {
                              borderColor: "#d32f2f",
                              boxShadow: "0 0 0 2px rgba(211, 47, 47, 0.1)",
                            },
                          },
                        }}
                      />
                      {/* Suggestions for upper limit */}
                      {focusedField === `${filter.id}-high` &&
                        getSuggestions(filter.id).length > 0 && (
                          <Paper
                            sx={{
                              position: "absolute",
                              top: "100%",
                              left: 0,
                              right: 0,
                              zIndex: 10,
                              mt: 0.5,
                              maxHeight: 150,
                              overflow: "auto",
                              borderRadius: 2,
                              border: "1.5px solid #d32f2f",
                              boxShadow: "0 4px 12px rgba(211, 47, 47, 0.15)",
                            }}
                            elevation={0}
                          >
                            {getSuggestions(filter.id).map(
                              (suggestion, index) => (
                                <Box
                                  key={index}
                                  data-suggestion="true" // Add data attribute for identification
                                  sx={{
                                    p: 1.2,
                                    cursor: "pointer",
                                    borderBottom: "1px solid #f0f0f0",
                                    background: "linear-gradient(90deg, rgba(255,255,255,1) 0%, rgba(245,245,245,1) 100%)",
                                    "&:hover": {
                                      bgcolor: "rgba(211, 47, 47, 0.08)",
                                      borderBottomColor: "#d32f2f",
                                    },
                                    "&:last-child": {
                                      borderBottom: "none",
                                    },
                                  }}
                                  onClick={() => {
                                    handleSuggestionClick(
                                      filter.id,
                                      "high",
                                      suggestion.value
                                    );
                                  }}
                                >
                                  <Typography
                                    variant="body2"
                                    sx={{ textAlign: "center" }}
                                  >
                                    {suggestion.label}
                                  </Typography>
                                </Box>
                              )
                            )}
                          </Paper>
                        )}
                    </Box>

                    <Typography
                      variant="body2"
                      sx={{ minWidth: "30px", textAlign: "center" }}
                    >
                      تا
                  </Typography>

                    {/* از (From) - lower limit */}
                    <Box sx={{ flex: 1, position: "relative" }}>
                      <TextField
                        size="small"
                        placeholder="از"
                        value={rangeFilter.low}
                        onChange={(e) =>
                          handleRangeFilterChange(
                            filter.id,
                            "low",
                            e.target.value
                          )
                        }
                        onFocus={() => setFocusedField(`${filter.id}-low`)}
                        onBlur={(e) => {
                          // Use setTimeout to allow click event to process first
                          setTimeout(() => {
                            // Check if the related target (what was clicked) is inside our suggestions
                            const relatedTarget = e.relatedTarget;
                            const isClickingSuggestion =
                              relatedTarget &&
                              relatedTarget.closest &&
                              relatedTarget.closest("[data-suggestion]");

                            if (!isClickingSuggestion) {
                              setFocusedField(null);
                            }
                          }, 150);
                        }}
                        fullWidth
                        type="number"
                        inputProps={{
                          min: filter.min,
                          max: rangeFilter.high || filter.max,
                          style: { textAlign: "center" },
                          autoComplete: "off",
                          autoCorrect: "off",
                          autoCapitalize: "off",
                          spellCheck: "false",
                        }}
                        autoComplete="off"
                        name={`filter-${filter.id}-low`}
                        sx={{
                          "& .MuiOutlinedInput-root": {
                            borderRadius: 2.5,
                            backgroundColor: "rgba(255, 255, 255, 0.8)",
                            border: "1.5px solid #e0e0e0",
                            "&:hover": {
                              borderColor: "#d32f2f",
                              backgroundColor: "rgba(255, 255, 255, 1)",
                            },
                            "&.Mui-focused": {
                              borderColor: "#d32f2f",
                              boxShadow: "0 0 0 2px rgba(211, 47, 47, 0.1)",
                            },
                          },
                        }}
                      />
                      {/* Suggestions for lower limit */}
                      {focusedField === `${filter.id}-low` &&
                        getSuggestions(filter.id).length > 0 && (
                          <Paper
                            sx={{
                              position: "absolute",
                              top: "100%",
                              left: 0,
                              right: 0,
                              zIndex: 10,
                              mt: 0.5,
                              maxHeight: 150,
                              overflow: "auto",
                              borderRadius: 2,
                              border: "1.5px solid #d32f2f",
                              boxShadow: "0 4px 12px rgba(211, 47, 47, 0.15)",
                            }}
                            elevation={0}
                          >
                            {getSuggestions(filter.id).map(
                              (suggestion, index) => (
                                <Box
                                  key={index}
                                  data-suggestion="true" // Add data attribute for identification
                                  sx={{
                                    p: 1.2,
                                    cursor: "pointer",
                                    borderBottom: "1px solid #f0f0f0",
                                    background: "linear-gradient(90deg, rgba(255,255,255,1) 0%, rgba(245,245,245,1) 100%)",
                                    "&:hover": {
                                      bgcolor: "rgba(211, 47, 47, 0.08)",
                                      borderBottomColor: "#d32f2f",
                                    },
                                    "&:last-child": {
                                      borderBottom: "none",
                                    },
                                  }}
                                  onClick={() => {
                                    handleSuggestionClick(
                                      filter.id,
                                      "low",
                                      suggestion.value
                                    );
                                  }}
                                >
                                  <Typography
                                    variant="body2"
                                    sx={{ textAlign: "center", color: "#333", fontWeight: 500 }}
                                  >
                                    {suggestion.label}
                                  </Typography>
                                </Box>
                              )
                            )}
                          </Paper>
                        )}
                    </Box>
                  </Box>

                  {/* Number in words display */}
                  {(rangeFilter.low !== "" || rangeFilter.high !== "") && (
                    <Box
                      sx={{
                        mt: 1.5,
                        p: 1.5,
                        background: "linear-gradient(135deg, rgba(211, 47, 47, 0.05) 0%, rgba(192, 192, 192, 0.05) 100%)",
                        borderRadius: 2,
                        border: "1px solid rgba(211, 47, 47, 0.1)",
                      }}
                    >
                      <Typography variant="caption" sx={{ color: "#666", fontWeight: 500 }}>
                        {rangeFilter.low !== "" && (
                          <span>
                            از {formatNumber(rangeFilter.low)} {filter.unit}{" "}
                          </span>
                        )}
                        {rangeFilter.low !== "" && rangeFilter.high !== "" && (
                          <span>تا </span>
                        )}
                        {rangeFilter.high !== "" && (
                          <span>
                            {formatNumber(rangeFilter.high)} {filter.unit}
                          </span>
                        )}
                      </Typography>
                    </Box>
                  )}
                </Grid>
              );
            })}
          </Grid>
        </AccordionDetails>
      </Accordion>
    </Box>
  );

  return (
    <>
      {/* Apply margin to body/content when filter is open on desktop */}
      {!isMobile && isFilterOpen && (
        <style jsx global>{`
          body {
            margin-right: 500px;
            transition: margin-right 0.3s ease-in-out;
          }
        `}</style>
      )}

      {!isMobile && !isFilterOpen && (
        <style jsx global>{`
          body {
            margin-right: 0;
            transition: margin-right 0.3s ease-in-out;
          }
        `}</style>
      )}

      {/* Filter & Sort Buttons */}
      <Box
        sx={{
          position: "fixed",
          top: isMobile ? 125 : 80,
          right: 16,
          zIndex: 1000,
          display: "flex",
          flexDirection: "column",
          gap: 1,
        }}
      >
        <Button
          onClick={() => setIsFilterOpen(true)}
          variant="contained"
          sx={{
            width: "auto", // Changed from fixed 56px to auto for text
            height: 56,
            borderRadius: "50px", // Changed from circle to pill shape
            background: "linear-gradient(135deg, #808080 0%, #c0c0c0 100%)",
            color: "white",
            boxShadow: "0 2px 8px rgba(128,128,128,0.3)",
            px: 2, // Add horizontal padding for text
            "&:hover": {
              background: "linear-gradient(135deg, #a9a9a9 0%, #d3d3d3 100%)",
            },
          }}
        >
          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            <Typography variant="body2" sx={{ fontWeight: 600 }}>
              فیلترها
    </Typography>
            <Tune sx={{ fontSize: 24 }} />
          </Box>
        </Button>
      </Box>

      {/* Sort Menu */}
      <Menu
        anchorEl={sortAnchorEl}
        open={Boolean(sortAnchorEl)}
        onClose={() => setSortAnchorEl(null)}
      >
        <MenuItem
          onClick={() => handleSortChange("newest")}
          selected={sortBy === "newest"}
        >
          جدیدترین
        </MenuItem>
        <MenuItem
          onClick={() => handleSortChange("oldest")}
          selected={sortBy === "oldest"}
        >
          قدیمی ترین
        </MenuItem>
        <MenuItem
          onClick={() => handleSortChange("most_viewed")}
          selected={sortBy === "most_viewed"}
        >
          پر بازدید ترین
        </MenuItem>
      </Menu>

      {/* Filter Panel */}
      <Box
        sx={{
          position: "fixed",
          top: 0,
          right: isFilterOpen ? 0 : isMobile ? "-100%" : -500,
          width: isMobile ? "100%" : 500,
          height: "100vh",
          bgcolor: "background.paper",
          boxShadow: 3,
          borderLeft: "1px solid",
          borderColor: "divider",
          transition: "right 0.3s ease-in-out",
          zIndex: 1200,
          display: "flex",
          flexDirection: "column",
        }}
      >
        {/* Header */}
        <Box
          sx={{
            background: "linear-gradient(135deg, #808080 0%, #c0c0c0 100%)",
            color: "white",
            p: 2,
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            borderBottom: "1px solid #a9a9a9",
          }}
        >
          <Button
            onClick={() => {
              if (filterLevel !== "base") {
                setFilterLevel("base");
              } else {
                setIsFilterOpen(false);
              }
            }}
            color="inherit"
            sx={{ "&:hover": { background: "linear-gradient(135deg, #a9a9a9 0%, #d3d3d3 100%)" } }}
          >
            {filterLevel === "base" ? <Close /> : <ArrowBack />}
          </Button>
          <Typography variant="h6" sx={{ fontWeight: 600 }}>فیلترها</Typography>
          <Button onClick={handleResetAll} color="inherit" size="small" sx={{ "&:hover": { background: "linear-gradient(135deg, #a9a9a9 0%, #d3d3d3 100%)" } }}>
            حذف همه
          </Button>
        </Box>

        {/* Selected Filters - Only show on desktop */}
        {!isMobile && renderSelectedFilters()}

        {/* Content */}
        <Box sx={{ flex: 1, overflow: "auto", mb: 3 }}>
          {filterLevel === "category" ? (
            <Box sx={{ p: 2 }}>
              {loading ? (
                <Box
                  sx={{
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    p: 4,
                  }}
                >
                  <CircularProgress size={40} sx={{ mb: 2 }} />
                  <Typography variant="body2" color="text.secondary">
                    Loading categories...
                  </Typography>
                </Box>
              ) : categories.length === 0 ? (
                <Typography
                  sx={{ textAlign: "center", p: 3 }}
                  color="text.secondary"
                >
                  No categories available
                </Typography>
              ) : (
                    <Grid container spacing={2}>
                      {categories.map((category) => (
                        <Grid item xs={6} key={category.id}>
                          <Box
                            sx={{
                              display: "flex",
                              alignItems: "center",
                              p: 2,
                              cursor: "pointer",
                              border: "1px solid",
                              borderColor:
                                selectedCategory?.id === category.id
                                  ? "primary.main"
                                  : "grey.300",
                              borderRadius: 1,
                              bgcolor:
                                selectedCategory?.id === category.id
                                  ? "primary.light"
                                  : "white",
                              "&:hover": {
                                bgcolor:
                                  selectedCategory?.id === category.id
                                    ? "primary.light"
                                    : "grey.50",
                                borderColor:
                                  selectedCategory?.id === category.id
                                    ? "primary.main"
                                    : "grey.400",
                              },
                              transition: "all 0.2s ease-in-out",
                              height: "100%",
                              minHeight: "80px",
                            }}
                            onClick={() => handleCategorySelect(category)}
                          >
                            {selectedCategory?.id === category.id ? (
                              <RadioButtonChecked color="primary" sx={{ ml: 1 }} />
                            ) : (
                                <RadioButtonUnchecked
                                  sx={{ ml: 1, color: "grey.500" }}
                                />
                              )}
                            <Typography
                              sx={{
                                ml: 2,
                                fontWeight: 500,
                                textAlign: "right",
                                flex: 1,
                              }}
                            >
                              {category.name}
                            </Typography>
                          </Box>
                        </Grid>
                      ))}
                    </Grid>
                  )}
            </Box>
          ) : filterLevel === "region" ? (
            <Box sx={{ p: 2 }}>
              {loading ? (
                <Box
                  sx={{
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    p: 4,
                  }}
                >
                  <CircularProgress size={40} sx={{ mb: 2 }} />
                  <Typography variant="body2" color="text.secondary">
                    Loading neighborhoods...
                  </Typography>
                </Box>
              ) : neighborhoods.length === 0 ? (
                <Typography
                  sx={{ textAlign: "center", p: 3 }}
                  color="text.secondary"
                >
                  No neighborhoods available
                </Typography>
              ) : (
                    <Grid container spacing={1}>
                      {neighborhoods.map((neighborhood) => (
                        <Grid item xs={12} md={6} key={neighborhood.id}>
                          <Button
                            variant={
                              selectedNeighborhoods.some(
                                (n) => n.id === neighborhood.id
                              )
                                ? "contained"
                                : "outlined"
                            }
                            fullWidth
                            startIcon={
                              selectedNeighborhoods.some(
                                (n) => n.id === neighborhood.id
                              ) ? (
                                  <CheckBox />
                                ) : (
                                  <CheckBoxOutlineBlank />
                                )
                            }
                            onClick={() => handleNeighborhoodToggle(neighborhood)}
                            sx={{ justifyContent: "flex-start" }}
                          >
                            {neighborhood.name}
                          </Button>
                        </Grid>
                      ))}
                    </Grid>
                  )}
            </Box>
          ) : (
                <Box sx={{ p: 2 }}>
                  {/* Sort Button */}
                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                      mb: 2,
                    }}
                  >
                    <Button
                      onClick={(e) => setSortAnchorEl(e.currentTarget)}
                      variant="outlined"
                      size="small"
                      startIcon={<Sort />}
                    >
                      {getSortDisplayText()}
                    </Button>
                    <span>مرتب‌سازی</span>
                  </Box>
                  <Divider />

                  {/* Category Selection */}
                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                      my: 2,
                    }}
                  >
                    <Button
                      onClick={() => setFilterLevel("category")}
                      variant="outlined"
                      size="small"
                    >
                      {selectedCategory ? "تغییر" : "انتخاب"}
                    </Button>
                    <span>
                      {selectedCategory
                        ? `دسته بندی: ${selectedCategory.name}`
                        : "انتخاب دسته بندی"}
                    </span>
                  </Box>
                  <Divider />

                  {/* Neighborhood Selection */}
                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                      my: 2,
                    }}
                  >
                    <Button
                      onClick={() => setFilterLevel("region")}
                      variant="outlined"
                      size="small"
                    >
                      {selectedNeighborhoods.length > 0 ? "تغییر" : "انتخاب"}
                    </Button>
                    <span>
                      {selectedNeighborhoods.length > 0
                        ? `محلات: ${selectedNeighborhoods
                          .slice(0, 2)
                          .map((n) => n.name)
                          .join("، ")}${selectedNeighborhoods.length > 2 ? "..." : ""
                        }`
                        : "انتخاب محلات"}
                    </span>
                  </Box>
                  <Divider />

                  {/* Range Filters Section - Now in collapsible accordion */}
                  {renderRangeFilters()}

                  {/* Features Section - Now below range filters */}
                  {renderFeatures()}
                </Box>
              )}
        </Box>

        {/* Footer */}
        {filterLevel === "base" && (
          <Box sx={{ p: 2, borderTop: "1px solid #e0e0e0", bgcolor: "#f5f5f5" }}>
            <Button
              variant="contained"
              fullWidth
              onClick={() => setIsFilterOpen(false)}
              sx={{
                background: "linear-gradient(135deg, #808080 0%, #c0c0c0 100%)",
                color: "white",
                fontWeight: 600,
                py: 1.5,
                "&:hover": {
                  background: "linear-gradient(135deg, #a9a9a9 0%, #d3d3d3 100%)",
                },
              }}
            >
              نمایش {applyFilters().length} آگهی
            </Button>
          </Box>
        )}
      </Box>

      {/* Overlay for mobile */}
      {isFilterOpen && isMobile && (
        <Box
          sx={{
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            bgcolor: "rgba(0, 0, 0, 0.5)",
            zIndex: 1199,
          }}
          onClick={() => setIsFilterOpen(false)}
        />
      )}

      {/* Mobile Filter Tags Bar - Fixed below header */}
      {isMobile && (
        <Box
          sx={{
            position: "fixed",
            top: 70,
            left: 0,
            right: 0,
            p: 1,
            borderBottom: "1px solid",
            borderColor: "divider",
            maxHeight: "100px",
            overflow: "auto",
            bgcolor: "background.paper",
            zIndex: 100,
            display:
              selectedCategory ||
                selectedNeighborhoods.length > 0 ||
                selectedFeatures.length > 0 ||
                rangeFilters.some((f) => f.low !== "" || f.high !== "")
                ? "block"
                : "none",
          }}
        >
          <Stack direction="row" spacing={0.5} flexWrap="wrap" useFlexGap>
            {selectedCategory && (
              <Chip
                label={selectedCategory.name}
                onDelete={() => {
                  setSelectedCategory(null);
                  if (onCategoryChange) onCategoryChange(null);
                }}
                size="small"
                variant="outlined"
              />
            )}

            {selectedNeighborhoods.map((neighborhood) => (
              <Chip
                key={neighborhood.id}
                label={neighborhood.name}
                onDelete={() =>
                  setSelectedNeighborhoods((prev) =>
                    prev.filter((n) => n.id !== neighborhood.id)
                  )
                }
                size="small"
                variant="outlined"
              />
            ))}

            {selectedFeatures.map((feature) => (
              <Chip
                key={feature.value}
                label={feature.value}
                onDelete={() =>
                  setSelectedFeatures((prev) =>
                    prev.filter((f) => f.value !== feature.value)
                  )
                }
                size="small"
                variant="outlined"
              />
            ))}

            {rangeFilters
              .map((filter) => {
                if (filter.low !== "" || filter.high !== "") {
                  let label = "";
                  if (filter.low !== "" && filter.high !== "") {
                    label = `${formatNumberWithWords(filter.low)}-${formatNumberWithWords(filter.high)}`;
                  } else if (filter.low !== "") {
                    label = `${formatNumberWithWords(filter.low)}+`;
                  } else if (filter.high !== "") {
                    label = `-${formatNumberWithWords(filter.high)}`;
                  }
                  return (
                    <Chip
                      key={filter.id}
                      label={label}
                      onDelete={() => {
                        setRangeFilters((prev) =>
                          prev.map((f) =>
                            f.id === filter.id ? { ...f, low: "", high: "" } : f
                          )
                        );
                      }}
                      size="small"
                      variant="outlined"
                    />
                  );
                }
                return null;
              })
              .filter(Boolean)}
          </Stack>
        </Box>
      )}
    </>
  );
};

export default WorkerFilter;
